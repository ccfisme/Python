## 漏掉连续数的remove？？！！！

今天做了一个remove的题，属实惊到我了，众所周知，remove是用来删指定元素的，这没毛病，直到我看到这个题：</br>
例一：</br>
```

lst=[34,6,7,0,0,0,9]
n=0
for i in lst:
    if i==0:
        lst.remove(i)
        n+=1
print(n)
# n = 2
```

? ? ?</br>

怎么不是3？真离谱，一开始我怀疑是for循环的事儿，结果for循环源码就单纯的迭代器和指向下一个元素，没别的，然后做到下一个题，我更迷糊了</br>
例二：</br>
```
lst=[0,0,0,0,0,0,9]
n=0
for i in lst:
    if i==0:
        lst.remove(i)
        n+=1
print(n)
# n = 3
```
? ? ? ! !</br>
又是3了？就尼玛离谱</br>
因此，我把矛头指向remove函数的源代码，结果源代码没找到，答案却出来了</br>
```
在删掉第一个值，也就是索引[0]后，索引为[1]的值索引变为了[0]，然后第二次删除是从索引[1]开始删除的，所以漏掉了一个值。

```
结合for循环的迭代器原理，我一下子就明白了，当连续删除同一个数0且此数在索引[0]时，下一个0其实是下下一个0，如例二。

解答我疑惑的网址：https://blog.csdn.net/yzy_1996/article/details/88960229</br>
