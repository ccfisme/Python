  
  ![截屏2021-09-16 21 13 04](https://user-images.githubusercontent.com/74129445/133618489-c29adefe-9447-49df-b51e-2b6cab8ce102.png)</br></br>
在用python时发现不能对a，b两个数实现一次输入多组数据，要用到map，而想要map原理又要先明白迭代器，（map(fun, iter)，用到了迭代器，对迭代器进行函数操作后的堆指针常量返回给a，b）这是第二次碰到了，之前忘记是什么问题了，好像是c++碰到的，总之迭代器似乎只能用一次，而为什么会用到迭代器？以及迭代器对于这个语言的优势？这些我一点也不懂，所以对迭代器进行了底层原理的学习</br></br>
  参考:https://blog.csdn.net/weixin_38736371/article/details/80873865</br></br>

  首先我的直观印象是迭代器的工作原理类似指针，但我的汇编还没学到家，即使dis后也看不懂迭代器的工作原理，所以想从网上找一个对迭代器的底层机制介绍，先看了几个对迭代器浅显一点的介绍，明白了这个是个对象，不是指针，其次它可以对容器内的“元素”进行遍历，这里我是理解为迭代器是一个类似于娃娃机爪子的物品，当得到命令后，会将娃娃机里的该位置的娃娃复制一个，然后丢出，这也就解释了为什么迭代器只能用一次，并且根据资料显示迭代器的查询是不可逆的，但是具体迭代器是怎么对容器内部进行查找操作的，我还没弄清，所以，我又继续找了一些网站，希望找到迭代器的底层代码或者对汇编的解释。</br></br>
  
  参考:https://foofish.net/iterators-vs-generators.html</br>
  https://www.liaoxuefeng.com/wiki/1016959663602400/1017106984190464</br>
  
  庆幸的是，我找到了一篇文章，虽然没有全部读明白，但是我大致明白了迭代器内部用到的对象需要靠iter()和next() 函数来创建一个迭代器并输出迭代器的下一个元素，以及一个类似于可存放多个抓出来的娃娃的娃娃机出口的生成器yield函数，但我还没明白iter()和next() 函数的源代码以及迭代器的优势，所以针对这两个问题，我又进行了搜索，哎，这该死的知识贫瘠。</br></br>
  参考:https://www.zhihu.com/question/54047747/answer/137783330</br></br>
  找到一篇文章，了解了迭代器相对于指针的优势，总之一句话，使编程时的工作量，思考量减少。但是很可惜，我没找到iter()和next() 函数的源代码，不过我有了一些思路，所以准备这几天自己试试</br></br>
  ![截屏2021-09-16 22 25 50](https://user-images.githubusercontent.com/74129445/133630063-0d561a34-5d59-481c-ade7-53fad045f12b.png)</br></br>
现在看来，娃娃机的例子是错误的，至少不应该是复制一个数据，而是对对象直接操作。</br></br>
这次又发现新的理解性错误，迭代器并不会有自动清空机制，先上代码</br>
a = input().split()</br>
m = map(int, a)</br>
print(sum(m))//有值</br>
print(sum(m))//恒为0</br>
会发现输入数据后，第一次为正常的sum值，但第二次为零，证明返回的根本不是数据的地址，而是返回的迭代器的指针常量，即把迭代器作为对象赋给了m</br>
那么，我这次再看迭代器的观点：之前理解为迭代器返回列表某个对象的地址，但现在觉得是返回迭代器的地址，并且下一次迭代器会清空</br>
下面，我决定从源代码中找到能够证明我对迭代器的两个猜想，一是返回迭代器的地址，二是下一次迭代器会清空。　</br>
找到的第一个有用的是这个https://www.cnblogs.com/chenweilin/p/12692070.html</br>
但是我没看懂，所以我决定直接对问题进行查找，不自己想了，不过这个代码我想自己写写</br>
结合https://www.cnblogs.com/xiaxiaoxu/p/11979179.html</br>
https://blog.csdn.net/swety_gxy/article/details/83063499</br>
让我理解了大致运行原理，即map迭代器运行时仍会返回一个指针常量（也就是对象），不过是迭代器的一个自定义的指针常量，是一个指向当前所有迭代数的一个列表迭代器
，map() 函数将对迭代器内的所有项目应用给定的函数，并返回一个可迭代的映射对象，即元组、列表等，并且迭代器只能向前遍历，这也就是为0原因，所以m作为一个map返回的迭代器而言，使用后就立即运行迭代器功能，指向下一个，而第二个sum下一个没有，因为sum是全表遍历，所以第二个sum只能为0
